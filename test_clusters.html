<!DOCTYPE html>
<html>

<head>
  <title>westcoastmap</title>

  <!-- <link rel="stylesheet" href="http://cdn.leafletjs.com/leaflet-0.7/leaflet.css" /> -->

  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.0.3/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet@1.0.3/dist/leaflet.js"></script>
  <script src="https://unpkg.com/leaflet-providers@latest/leaflet-providers.js"></script>

  <!-- <script src="http://cdn.leafletjs.com/leaflet-0.7/leaflet.js"></script> -->
  <!--  <script src='leaflet-omnivore.min.js'></script>-->
  <script src='//api.tiles.mapbox.com/mapbox.js/plugins/leaflet-omnivore/v0.3.1/leaflet-omnivore.min.js'></script>
  <script src="http://d3js.org/d3.v4.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/d3-delaunay@6"></script>

  <link rel="preconnect" href="https://fonts.gstatic.com">
  <link href="https://fonts.googleapis.com/css2?family=Beth+Ellen&display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=Kalam&display=swap" rel="stylesheet">
</head>

<body>
  <div id="map"></div>


  <style>
  #map { 
    height: 100%
  }
  html, body {
    height: 100%;
    margin: 0;
    padding: 0;
  }
  </style> 

  
  <script type="text/javascript">

    var unitRadius = 4;     // The pixel radius of a point of size = 1
    var partitionSize = 30;


    var mergePoints = function(a, b) {
      var weight = b.r / (a.r + b.r);
      return {
        x: a.x + weight * (b.x - a.x),
        y: a.y + weight * (b.y - a.y),
        r: unitRadius * Math.sqrt(a.points.length + b.points.length),
        points: a.points.concat(b.points)
      };
    };


    var initClusterArray = function(points) {
      var clusters = points.map(function(d, i) {
        var p = map.latLngToLayerPoint([d.lat, d.lng]);
          return {
            x: p.x,
            y: p.y,
            r: unitRadius,
            points: [d]
          };
        });

      // Consolidate coincident vertices. The voronoi tesselation will not
      // work if there are duplicate vertices.
      return d3.nest()
        .key(function(d) { return [d.x.toFixed(3), d.y.toFixed(3)].join(','); })
        .rollup(function(leaves) { return leaves.reduce(mergePoints); })
        .entries(clusters)
        .map(function(d, i) { return d.value; });
    };


    var overlap = function(points) {
      // console.log(initClusterArray(points))
        var clusters = initClusterArray(points).map(function(d, i) { d.index = i; return d; }),
            maxRadius = d3.max(clusters, function(d) { return d.r; }),
            hasClusters = true;

        // Loop until we don't find any more clusters
        while (hasClusters) {
            hasClusters = false;

            // Create an array of the edges of a Delaunay triangulation,
            // sorted by distance (from smallest to largest).
            //
            // One of the properties of a Delaunay triangulation is that
            // at least one of the edges connected to a node is its nearest
            // neighbor.
            vertices = []
            clusters.filter(function(v) { return !!v; }).forEach(d => vertices.push([d.x, d.y]))
            vertices = vertices.flat(Infinity)
            const delaunay = new d3.Delaunay(vertices)
            // console.log(delaunay)   // build set of links (source, target) with distance, sort them by distance; links are done with neighbours

            links = []

          console.log(clusters.filter(function(v) { return !!v; }).map(d => ([d.x, d.y])))
          console.log(vertices)
          console.log(delaunay)
            
            for (var i = 0; i < clusters.filter(function(v) { return !!v; }).length; ++i) {
              for (let nbr of delaunay.neighbors(i)) {
                if (nbr > i) {
                  console.log(i, nbr, clusters.filter(function(v) { return !!v; })[i], clusters.filter(function(v) { return !!v; })[nbr])
                  if ((clusters.filter(function(v) { return !!v; })[i] !== null)&(clusters.filter(function(v) { return !!v; })[nbr] !== null)){
                    obj = new Object()
                    obj.source = clusters.filter(function(v) { return !!v; })[i]
                    obj.target = clusters.filter(function(v) { return !!v; })[nbr]
                    dx = obj.source.x - obj.target.x
                    dy = obj.source.y - obj.target.y
                    obj.distance = Math.sqrt(dx * dx + dy * dy)
                    links.push(obj)
                  }
                }
              }
            }

            links = links.sort(function(a, b) {
                    return a.distance - b.distance;
                });

            console.log(links)


            // Iterate through the edges, from smallest to largest distance.
            // The first line will be between the closest pair of points,
            // the second line will be between the second closest pair, etc.
            //
            // We use Array.prototype.every() so that we can return false
            // in order to break out of the loop.
            links.every(function(link) {
                // If the distance is larger than twice the largest radius,
                // then we can stop iterating, because we know that this
                // and all remaining points are too far apart to overlap.
                console.log(link.distance, link.source.r, link.target.r, link.source, link.target)
                if (link.distance > maxRadius * 2) {
                    console.log(`link distance is large ${link.distance}  ${maxRadius}`)
                    return false;
                }

                // If the distance between the points is smaller than the
                // sum of the two points" radii, they overlap and need to
                // be merged together.
                if (link.distance < link.source.r + link.target.r) {
                   console.log(`link distance is smol ${link.distance}  ${link.source.r + link.target.r}`)
                    var cluster = mergePoints(link.source, link.target);

                    // Set the cluster's index to that of the source node
                    cluster.index = link.source.index;

                    // Set the target node in the clusters array to null
                    clusters[link.target.index] = null;

                    // Replace the source node with the merged point
                    clusters[link.source.index] = cluster;

                    // Update our maximum radius
                    maxRadius = Math.max(maxRadius, cluster.r);

                    // Set flag, so that the outer (while) loop runs again
                    hasClusters = true;

                    // Break out of the loop, then re-do Delaunay triangulation
                    // and try to find another pair of points that overlap.
                    return false;
                }
                return true;
            });
            // clusters = clusters.filter(function(v) { return !!v; })
        }

        // Return our cluster array, filtering out the nulls we inserted
        // while clustering
        return clusters.filter(function(v) { return !!v; });
    };

    var map = L.map('map').setView([47.5145124,-123.3290252], 7.01);
    // var map = L.map('map').setView([38.027336, -122.826623], 13.01);

    // 'https://api.mapbox.com/styles/v1/astrofyz/clm1f0crg020t01p91frx3ni2/tiles/256/{z}/{x}/{y}@2x?access_token=pk.eyJ1IjoiYXN0cm9meXoiLCJhIjoiY2xtMWF4MTBxMzByMTNxcGkwc2cycDlhMSJ9.0o3QKpA4eMmFsX2pfk-Idw'

    // mapLink =
    //   '<a href="http://openstreetmap.org">OpenStreetMap</a>';
    // L.tileLayer(
    //   'https://tile.openstreetmap.org/{z}/{x}/{y}.png', {
    //     attribution: 'Â© OpenStreetMap',
    //     maxZoom: 18,
    //   }).addTo(map);

    L.tileLayer.provider('Stadia.StamenWatercolor').addTo(map);


    // We pick up the SVG from the map object
    var svgLayer = L.svg({clickable:true});
    svgLayer.addTo(map);

    var svg = d3.select("#map").select("svg");
    var g = d3.select("#map").select("svg").select('g');
    g.attr("class", "leaflet-zoom-hide");


    d3.csv("df_places_Seattle.csv", function(data) {
      points = []

      data.forEach(function(d) {
        points.push(new L.LatLng(parseFloat(d.latitude), parseFloat(d.longitude)));
        d.LatLng = new L.LatLng(parseFloat(d.latitude), parseFloat(d.longitude))
      })

      // console.log(initClusterArray(points))

      // console.log(points)

      // var mediacount = d3.nest()
      //   .key(function(d) {
      //     return d.LatLng;
      //   })
      //   .entries(data);


      var clusters = overlap(points)


      var feature = g.selectAll("circle")
              .data(clusters)
              .enter()
              .append("circle")
              .attr("cx", function(d) { return d.x; })
              .attr("cy", function(d) { return d.y; })
              .attr("r", function(d) { return d.r; })
              .on("mouseover", function(d) {console.log(d.x, d.y, d.points.length)})


      map.on("viewreset", function() {alert("VIEW RESET"); update});  // doesn't fire at zoom events in leaflet > 1.0
      map.on("zoomend", function(){
        d3.selectAll("circle").remove();
        d3.selectAll("text").remove();
        update
      })
      map.on("moveend", update)
      update();
      //
      function update() {
        var clusters = overlap(points)
        // console.log(clusters.length)
        // clusters.forEach(d => console.log(d.points.length, d))

        var elem = g.selectAll("g myCircleText")
                .data(clusters)

        var elemEnter = elem.enter()
                .append("g")
                .attr("class", "node-group")

        var circleInner = elemEnter.append("circle")
                .attr("r", function(d) {
                  return d.r
                })
                .attr("cx", function(d) { return d.x; })
                .attr("cy", function(d) { return d.y; })
                .attr("stroke", "black")
                .attr("fill", "red");

        // var circleOuter = elemEnter.append("circle")
        //         .attr("r", function(d) {
        //           return d.r
        //         })
        //         .attr("cx", function(d) { return d.x; })
        //         .attr("cy", function(d) { return d.y; })
        //         .attr("stroke", "black")
        //         .attr("fill", "blue");

        elemEnter.append("text")
                .text(function(d) {
                  return d.points.length > 1 ? `${d.points.length}` : ""
                })
                .attr("x", function(d) { return d.x-d.r/2; })
                .attr("y", function(d) { return d.y+d.r/2; })
                .attr({
                  "text-anchor": "middle",
                  "font-size": function(d) {
                    return d.r / ((d.r * 10) / 100);
                  },
                  "dy": function(d) {
                    return d.r / ((d.r * 25) / 100);
                  }
                });

        // var feature = g.selectAll("circle")
        //         .data(clusters)
        //         .enter()
        //         .append("circle")
        //         .attr("cx", function(d) { return d.x; })
        //         .attr("cy", function(d) { return d.y; })
        //         .attr("r", function(d) { return d.r; })
        //         .attr("opacity", 0.3)
        //         .attr("fill", "red")
        //         .on("mouseover", function(d) {console.log(d.x, d.y, d.points.length)})
        //         .append("text")
        //         .text(d =>  (d.points.length > 1) ? `${d.points.length}` : "")
        //         .attr("text-anchor", "middle")
        //         .attr("fill", "white")
        //         .attr("font-size", function(d) {return "18px"})
        //         .attr("y", d => d.y)
        //         .attr("x", d => d.x)
      }

    });

  </script>
</body>

</html>